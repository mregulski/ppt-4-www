<article>
    <h2>Testy pierwszości</h2>
    <h3>Algorytm Euklidesa</h3>
    <p>Test pierwszości to algorytm określający, czy dana liczba jest pierwsza, czy złożona. Nie jest to równoważne znalezieniu jej
        rozkładu na czynniki pierwsze. W obecnej chwili (2011 rok) nie są znane efektywne algorytmy rozkładu na czynniki pierwsze,
         natomiast testy pierwszości można przeprowadzać bardzo szybko.
    </p>

    <h3>Metoda Naiwna</h3>
    Najprostszy test pierwszości wygląda następująco: dla danej liczby <i>n</i> należy sprawdzić, czy dzieli się ona kolejno przez 2, 3, aż do <i>n−1</i>. Jeśli przez żadną z nich się nie dzieli, oznacza to, że jest pierwsza.

    Zamiast testować wszystkie liczby do <i>n−1</i>, wystarczy sprawdzić podzielność n przez liczby mniejsze lub równe pierwiastkowi z <i>n</i>.

    Kolejne udoskonalenie polega na sprawdzaniu podzielności n jedynie przez liczby pierwsze mniejsze lub równe pierwiastkowi z <i>n</i>. Ich listę łatwo możemy uzyskać metodą sita Eratostenesa. Metoda ta wciąż wymaga wykonania dużej liczby dzieleń, co oznacza, że już dla 50-cyfrowych liczb pierwszych jest niewykonalna na współczesnych komputerach.

    <h3>Testy probabilistyczne</h3>
    Obecnie najbardziej efektywne i najczęściej stosowane są testy probabilistyczne. Korzysta się w nich z losowo wygenerowanych liczb z ustalonego przedziału – pewien dobór tych wartości może dać błędny wynik testu, ale przy wybraniu wystarczająco wielu z nich prawdopodobieństwo takiego zdarzenia jest znikome.

    <h4>Przebieg testu probabilistycznego</h4>

    <ol>
        <li>Wybrać losowo liczbę <i>a</i>. <br></li>
        <li>Sprawdzić pewne równanie zawierające a oraz zadaną liczbę n. Jeśli okaże się fałszywe, zwrócić wynik <i>n jest złożona</i>. Wartość a jest wtedy świadkiem złożoności i test można zakończyć.</li>
        <li>Powtarzać całą procedurę, aż uzyska się wystarczającą pewność.</li>
    </ol>

    <section class="pseudo">
        <div class="code">
            <h4>Java</h3>
            <pre>
        <code>private static boolean fermatTest(int n, int k)
        {
            int a, i;
            Random rand = new Random();

            if (n < 4)
            {
                return true;
            }

            for (i=0; i < k; i++)
            {
                a = rand.nextInt(n-2) + 2;
                if (power_modulo_fast(a, n-1, n) != 1)
                {
                    return false;
                }
            }

            return true;
        }</code>
            </pre>
        </div>
        <div class="code">
            <h4>JavaScript</h3>
            <pre>
    <code>function fermatTest(var n, var k)
    {
        var a, i, result;

        if(n < 4)
        {
            result = " jest pierwsza!";
        }

        for (i = 0; i < k; i++)
        {
            a = Math.floor((Math.random() * (n-2) + 2));
            if (power_modulo_fast(a, n-1, n) != 1)
            {
                result = "Nie jest pierwsza.";
                return result;
            }
        }
        result = n + " prawdopodobnie jest pierwsza!";

        return result;
    }</code>
            </pre>
        </div>
    </section>

    <section>
        <h2>Test Pierwszości Fermata</h2>
        <div class="panel">
            Wprowadź liczbę n oraz dokładność testu  następnie naciśnij przycisk "Testuj".<br><br>
            <label for="varN">n:</label>
            <input type="number" min="1" max="1000000" value="17" id="varN">&nbsp;
            <label for="varK">Dokładność:</label>
            <input type="number" min="1" max="1000000" value="5" id="varK">&nbsp;
        </div>
        <button id="runButton" class="runButton" onClick="callRAE()">Testuj</button>
        <div id="output-wrapper">
            <h3>Wynik testu:</h3>
            <div id="output"></div>
        </div>
    </section>
</article>
